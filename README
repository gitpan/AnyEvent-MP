NAME
    AnyEvent::MP - multi-processing/message-passing framework

SYNOPSIS
       use AnyEvent::MP;

       $NODE      # contains this node's noderef
       NODE       # returns this node's noderef
       NODE $port # returns the noderef of the port

       $SELF      # receiving/own port id in rcv callbacks

       # ports are message endpoints

       # sending messages
       snd $port, type => data...;
       snd $port, @msg;
       snd @msg_with_first_element_being_a_port;

       # miniports
       my $miniport = port { my @msg = @_; 0 };

       # full ports
       my $port = port;
       rcv $port, smartmatch => $cb->(@msg);
       rcv $port, ping => sub { snd $_[0], "pong"; 0 };
       rcv $port, pong => sub { warn "pong received\n"; 0 };

       # remote ports
       my $port = spawn $node, $initfunc, @initdata;

       # more, smarter, matches (_any_ is exported by this module)
       rcv $port, [child_died => $pid] => sub { ...
       rcv $port, [_any_, _any_, 3] => sub { .. $_[2] is 3

       # monitoring
       mon $port, $cb->(@msg)      # callback is invoked on death
       mon $port, $otherport       # kill otherport on abnormal death
       mon $port, $otherport, @msg # send message on death

CURRENT STATUS
       AnyEvent::MP            - stable API, should work
       AnyEvent::MP::Intro     - outdated
       AnyEvent::MP::Kernel    - WIP
       AnyEvent::MP::Transport - mostly stable

       stay tuned.

DESCRIPTION
    This module (-family) implements a simple message passing framework.

    Despite its simplicity, you can securely message other processes running
    on the same or other hosts.

    For an introduction to this module family, see the AnyEvent::MP::Intro
    manual page.

    At the moment, this module family is severly broken and underdocumented,
    so do not use. This was uploaded mainly to reserve the CPAN namespace -
    stay tuned!

CONCEPTS
    port
        A port is something you can send messages to (with the "snd"
        function).

        Some ports allow you to register "rcv" handlers that can match
        specific messages. All "rcv" handlers will receive messages they
        match, messages will not be queued.

    port id - "noderef#portname"
        A port id is normaly the concatenation of a noderef, a hash-mark
        ("#") as separator, and a port name (a printable string of
        unspecified format). An exception is the the node port, whose ID is
        identical to its node reference.

    node
        A node is a single process containing at least one port - the node
        port. You can send messages to node ports to find existing ports or
        to create new ports, among other things.

        Nodes are either private (single-process only), slaves (connected to
        a master node only) or public nodes (connectable from unrelated
        nodes).

    noderef - "host:port,host:port...", "id@noderef", "id"
        A node reference is a string that either simply identifies the node
        (for private and slave nodes), or contains a recipe on how to reach
        a given node (for public nodes).

        This recipe is simply a comma-separated list of "address:port" pairs
        (for TCP/IP, other protocols might look different).

        Node references come in two flavours: resolved (containing only
        numerical addresses) or unresolved (where hostnames are used instead
        of addresses).

        Before using an unresolved node reference in a message you first
        have to resolve it.

VARIABLES/FUNCTIONS
    $thisnode = NODE / $NODE
        The "NODE" function returns, and the $NODE variable contains the
        noderef of the local node. The value is initialised by a call to
        "become_public" or "become_slave", after which all local port
        identifiers become invalid.

    $noderef = node_of $port
        Extracts and returns the noderef from a portid or a noderef.

    initialise_node $noderef, $seednode, $seednode...
    initialise_node "slave/", $master, $master...
        Before a node can talk to other nodes on the network it has to
        initialise itself - the minimum a node needs to know is it's own
        name, and optionally it should know the noderefs of some other nodes
        in the network.

        This function initialises a node - it must be called exactly once
        (or never) before calling other AnyEvent::MP functions.

        All arguments are noderefs, which can be either resolved or
        unresolved.

        There are two types of networked nodes, public nodes and slave
        nodes:

        public nodes
            For public nodes, $noderef must either be a (possibly
            unresolved) noderef, in which case it will be resolved, or
            "undef" (or missing), in which case the noderef will be guessed.

            Afterwards, the node will bind itself on all endpoints and try
            to connect to all additional $seednodes that are specified.
            Seednodes are optional and can be used to quickly bootstrap the
            node into an existing network.

        slave nodes
            When the $noderef is the special string "slave/", then the node
            will become a slave node. Slave nodes cannot be contacted from
            outside and will route most of their traffic to the master node
            that they attach to.

            At least one additional noderef is required: The node will try
            to connect to all of them and will become a slave attached to
            the first node it can successfully connect to.

        This function will block until all nodes have been resolved and, for
        slave nodes, until it has successfully established a connection to a
        master server.

        Example: become a public node listening on the default node.

           initialise_node;

        Example: become a public node, and try to contact some well-known
        master servers to become part of the network.

           initialise_node undef, "master1", "master2";

        Example: become a public node listening on port 4041.

           initialise_node 4041;

        Example: become a public node, only visible on localhost port 4044.

           initialise_node "locahost:4044";

        Example: become a slave node to any of the specified master servers.

           initialise_node "slave/", "master1", "192.168.13.17", "mp.example.net";

    $cv = resolve_node $noderef
        Takes an unresolved node reference that may contain hostnames and
        abbreviated IDs, resolves all of them and returns a resolved node
        reference.

        In addition to "address:port" pairs allowed in resolved noderefs,
        the following forms are supported:

        the empty string
            An empty-string component gets resolved as if the default port
            (4040) was specified.

        naked port numbers (e.g. 1234)
            These are resolved by prepending the local nodename and a colon,
            to be further resolved.

        hostnames (e.g. "localhost:1234", "localhost")
            These are resolved by using AnyEvent::DNS to resolve them,
            optionally looking up SRV records for the "aemp=4040" port, if
            no port was specified.

    $SELF
        Contains the current port id while executing "rcv" callbacks or
        "psub" blocks.

    SELF, %SELF, @SELF...
        Due to some quirks in how perl exports variables, it is impossible
        to just export $SELF, all the symbols called "SELF" are exported by
        this module, but only $SELF is currently used.

    snd $port, type => @data
    snd $port, @msg
        Send the given message to the given port ID, which can identify
        either a local or a remote port, and can be either a string or
        soemthignt hat stringifies a sa port ID (such as a port object :).

        While the message can be about anything, it is highly recommended to
        use a string as first element (a portid, or some word that indicates
        a request type etc.).

        The message data effectively becomes read-only after a call to this
        function: modifying any argument is not allowed and can cause many
        problems.

        The type of data you can transfer depends on the transport protocol:
        when JSON is used, then only strings, numbers and arrays and hashes
        consisting of those are allowed (no objects). When Storable is used,
        then anything that Storable can serialise and deserialise is
        allowed, and for the local node, anything can be passed.

    $local_port = port
        Create a new local port object that can be used either as a pattern
        matching port ("full port") or a single-callback port ("miniport"),
        depending on how "rcv" callbacks are bound to the object.

    $port = port { my @msg = @_; $finished }
        Creates a "miniport", that is, a very lightweight port without any
        pattern matching behind it, and returns its ID. Semantically the
        same as creating a port and calling "rcv $port, $callback" on it.

        The block will be called for every message received on the port.
        When the callback returns a true value its job is considered "done"
        and the port will be destroyed. Otherwise it will stay alive.

        The message will be passed as-is, no extra argument (i.e. no port
        id) will be passed to the callback.

        If you need the local port id in the callback, this works nicely:

           my $port; $port = port {
              snd $otherport, reply => $port;
           };

    reg $port, $name
    reg $name
        Registers the given port (or $SELF<<< if missing) under the name
        $name. If the name already exists it is replaced.

        A port can only be registered under one well known name.

        A port automatically becomes unregistered when it is killed.

    rcv $port, $callback->(@msg)
        Replaces the callback on the specified miniport (after converting it
        to one if required).

    rcv $port, tagstring => $callback->(@msg), ...
    rcv $port, $smartmatch => $callback->(@msg), ...
    rcv $port, [$smartmatch...] => $callback->(@msg), ...
        Register callbacks to be called on matching messages on the given
        full port (after converting it to one if required) and return the
        port.

        The callback has to return a true value when its work is done, after
        which is will be removed, or a false value in which case it will
        stay registered.

        The global $SELF (exported by this module) contains $port while
        executing the callback.

        Runtime errors during callback execution will result in the port
        being "kil"ed.

        If the match is an array reference, then it will be matched against
        the first elements of the message, otherwise only the first element
        is being matched.

        Any element in the match that is specified as "_any_" (a function
        exported by this module) matches any single element of the message.

        While not required, it is highly recommended that the first matching
        element is a string identifying the message. The one-string-only
        match is also the most efficient match (by far).

        Example: create a port and bind receivers on it in one go.

          my $port = rcv port,
             msg1 => sub { ...; 0 },
             msg2 => sub { ...; 0 },
          ;

        Example: create a port, bind receivers and send it in a message
        elsewhere in one go:

           snd $otherport, reply =>
              rcv port,
                 msg1 => sub { ...; 0 },
                 ...
           ;

    $closure = psub { BLOCK }
        Remembers $SELF and creates a closure out of the BLOCK. When the
        closure is executed, sets up the environment in the same way as in
        "rcv" callbacks, i.e. runtime errors will cause the port to get
        "kil"ed.

        This is useful when you register callbacks from "rcv" callbacks:

           rcv delayed_reply => sub {
              my ($delay, @reply) = @_;
              my $timer = AE::timer $delay, 0, psub {
                 snd @reply, $SELF;
              };
           };

    $guard = mon $port, $cb->(@reason)
    $guard = mon $port, $rcvport
    $guard = mon $port
    $guard = mon $port, $rcvport, @msg
        Monitor the given port and do something when the port is killed or
        messages to it were lost, and optionally return a guard that can be
        used to stop monitoring again.

        "mon" effectively guarantees that, in the absence of hardware
        failures, that after starting the monitor, either all messages sent
        to the port will arrive, or the monitoring action will be invoked
        after possible message loss has been detected. No messages will be
        lost "in between" (after the first lost message no further messages
        will be received by the port). After the monitoring action was
        invoked, further messages might get delivered again.

        In the first form (callback), the callback is simply called with any
        number of @reason elements (no @reason means that the port was
        deleted "normally"). Note also that *the callback must never die*,
        so use "eval" if unsure.

        In the second form (another port given), the other port ($rcvport)
        will be "kil"'ed with @reason, iff a @reason was specified, i.e. on
        "normal" kils nothing happens, while under all other conditions, the
        other port is killed with the same reason.

        The third form (kill self) is the same as the second form, except
        that $rvport defaults to $SELF.

        In the last form (message), a message of the form "@msg, @reason"
        will be "snd".

        As a rule of thumb, monitoring requests should always monitor a port
        from a local port (or callback). The reason is that kill messages
        might get lost, just like any other message. Another less obvious
        reason is that even monitoring requests can get lost (for exmaple,
        when the connection to the other node goes down permanently). When
        monitoring a port locally these problems do not exist.

        Example: call a given callback when $port is killed.

           mon $port, sub { warn "port died because of <@_>\n" };

        Example: kill ourselves when $port is killed abnormally.

           mon $port;

        Example: send us a restart message when another $port is killed.

           mon $port, $self => "restart";

    $guard = mon_guard $port, $ref, $ref...
        Monitors the given $port and keeps the passed references. When the
        port is killed, the references will be freed.

        Optionally returns a guard that will stop the monitoring.

        This function is useful when you create e.g. timers or other
        watchers and want to free them when the port gets killed:

          $port->rcv (start => sub {
             my $timer; $timer = mon_guard $port, AE::timer 1, 1, sub {
                undef $timer if 0.9 < rand;
             });
          });

    kil $port[, @reason]
        Kill the specified port with the given @reason.

        If no @reason is specified, then the port is killed "normally"
        (linked ports will not be kileld, or even notified).

        Otherwise, linked ports get killed with the same reason (second form
        of "mon", see below).

        Runtime errors while evaluating "rcv" callbacks or inside "psub"
        blocks will be reported as reason "die => $@".

        Transport/communication errors are reported as "transport_error =>
        $message".

    $port = spawn $node, $initfunc[, @initdata]
        Creates a port on the node $node (which can also be a port ID, in
        which case it's the node where that port resides).

        The port ID of the newly created port is return immediately, and it
        is permissible to immediately start sending messages or monitor the
        port.

        After the port has been created, the init function is called. This
        function must be a fully-qualified function name (e.g.
        "MyApp::Chat::Server::init"). To specify a function in the main
        program, use "::name".

        If the function doesn't exist, then the node tries to "require" the
        package, then the package above the package and so on (e.g.
        "MyApp::Chat::Server", "MyApp::Chat", "MyApp") until the function
        exists or it runs out of package names.

        The init function is then called with the newly-created port as
        context object ($SELF) and the @initdata values as arguments.

        A common idiom is to pass your own port, monitor the spawned port,
        and in the init function, monitor the original port. This two-way
        monitoring ensures that both ports get cleaned up when there is a
        problem.

        Example: spawn a chat server port on $othernode.

           # this node, executed from within a port context:
           my $server = spawn $othernode, "MyApp::Chat::Server::connect", $SELF;
           mon $server;

           # init function on C<$othernode>
           sub connect {
              my ($srcport) = @_;

              mon $srcport;

              rcv $SELF, sub {
                 ...
              };
           }

NODE MESSAGES
    Nodes understand the following messages sent to them. Many of them take
    arguments called @reply, which will simply be used to compose a reply
    message - $reply[0] is the port to reply to, $reply[1] the type and the
    remaining arguments are simply the message data.

    While other messages exist, they are not public and subject to change.

    lookup => $name, @reply
        Replies with the port ID of the specified well-known port, or
        "undef".

    devnull => ...
        Generic data sink/CPU heat conversion.

    relay => $port, @msg
        Simply forwards the message to the given port.

    eval => $string[ @reply]
        Evaluates the given string. If @reply is given, then a message of
        the form "@reply, $@, @evalres" is sent.

        Example: crash another node.

           snd $othernode, eval => "exit";

    time => @reply
        Replies the the current node time to @reply.

        Example: tell the current node to send the current time to $myport
        in a "timereply" message.

           snd $NODE, time => $myport, timereply => 1, 2;
           # => snd $myport, timereply => 1, 2, <time>

AnyEvent::MP vs. Distributed Erlang
    AnyEvent::MP got lots of its ideas from distributed Erlang (Erlang node
    == aemp node, Erlang process == aemp port), so many of the documents and
    programming techniques employed by Erlang apply to AnyEvent::MP. Here is
    a sample:

       http://www.Erlang.se/doc/programming_rules.shtml
       http://Erlang.org/doc/getting_started/part_frame.html # chapters 3 and 4
       http://Erlang.org/download/Erlang-book-part1.pdf      # chapters 5 and 6
       http://Erlang.org/download/armstrong_thesis_2003.pdf  # chapters 4 and 5

    Despite the similarities, there are also some important differences:

    *   Node references contain the recipe on how to contact them.

        Erlang relies on special naming and DNS to work everywhere in the
        same way. AEMP relies on each node knowing it's own address(es),
        with convenience functionality.

        This means that AEMP requires a less tightly controlled environment
        at the cost of longer node references and a slightly higher
        management overhead.

    *   Erlang uses processes and a mailbox, AEMP does not queue.

        Erlang uses processes that selctively receive messages, and
        therefore needs a queue. AEMP is event based, queuing messages would
        serve no useful purpose.

        (But see Coro::MP for a more Erlang-like process model on top of
        AEMP).

    *   Erlang sends are synchronous, AEMP sends are asynchronous.

        Sending messages in Erlang is synchronous and blocks the process.
        AEMP sends are immediate, connection establishment is handled in the
        background.

    *   Erlang can silently lose messages, AEMP cannot.

        Erlang makes few guarantees on messages delivery - messages can get
        lost without any of the processes realising it (i.e. you send
        messages a, b, and c, and the other side only receives messages a
        and c).

        AEMP guarantees correct ordering, and the guarantee that there are
        no holes in the message sequence.

    *   In Erlang, processes can be declared dead and later be found to be
        alive.

        In Erlang it can happen that a monitored process is declared dead
        and linked processes get killed, but later it turns out that the
        process is still alive - and can receive messages.

        In AEMP, when port monitoring detects a port as dead, then that port
        will eventually be killed - it cannot happen that a node detects a
        port as dead and then later sends messages to it, finding it is
        still alive.

    *   Erlang can send messages to the wrong port, AEMP does not.

        In Erlang it is quite possible that a node that restarts reuses a
        process ID known to other nodes for a completely different process,
        causing messages destined for that process to end up in an unrelated
        process.

        AEMP never reuses port IDs, so old messages or old port IDs floating
        around in the network will not be sent to an unrelated port.

    *   Erlang uses unprotected connections, AEMP uses secure authentication
        and can use TLS.

        AEMP can use a proven protocol - SSL/TLS - to protect connections
        and securely authenticate nodes.

    *   The AEMP protocol is optimised for both text-based and binary
        communications.

        The AEMP protocol, unlike the Erlang protocol, supports both
        language-independent text-only protocols (good for debugging) and
        binary, language-specific serialisers (e.g. Storable).

        It has also been carefully designed to be implementable in other
        languages with a minimum of work while gracefully degrading
        fucntionality to make the protocol simple.

    *   AEMP has more flexible monitoring options than Erlang.

        In Erlang, you can chose to receive *all* exit signals as messages
        or *none*, there is no in-between, so monitoring single processes is
        difficult to implement. Monitoring in AEMP is more flexible than in
        Erlang, as one can choose between automatic kill, exit message or
        callback on a per-process basis.

    *   Erlang tries to hide remote/local connections, AEMP does not.

        Monitoring in Erlang is not an indicator of process death/crashes,
        as linking is (except linking is unreliable in Erlang).

        In AEMP, you don't "look up" registered port names or send to named
        ports that might or might not be persistent. Instead, you normally
        spawn a port on the remote node. The init function monitors the you,
        and you monitor the remote port. Since both monitors are local to
        the node, they are much more reliable.

        This also saves round-trips and avoids sending messages to the wrong
        port (hard to do in Erlang).

SEE ALSO
    AnyEvent.

AUTHOR
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/

